---
toc: false
comments: false
layout: post
title: OOP, CSSE mini project Part 2
description: Building Game Levels
type: ccc
courses: { csse: {week: 14} }
---

{% include nav_oop.html %}

## OOP, Game Levels

Using heirarchy below, the start screen, game screens, and game over screens have been created.

```text
GameEnv
|   ├── Attributes:
│   |   ├── levels
│   |   ├── gameObjects
|   │   └── ...
|   |
|   ├── Methods: 
│   |    ├── update: update, draw
│   |    ├── destroy: all gameObjects
│   |    └── ...
│
├── GameObject
│   ├── Player: sprite animation, wasd
│   ├── Background: fit to screen, scrolling 
│   ├── Platform: fixed to bottom, scrolling
│   └── ...
│
├── GameLevel
|   ├── Tag: key
│   ├── Attributes:
│   |   ├── playerAssets
│   |   ├── backgroundAssets
│   |   ├── platformAssets
│   |   └── ...
|   |
│   └── Methods: 
│   |    ├── load: "new" GameObject created from assets
│   |    └── ...
|
└── GameControl
│   ├── Methods: 
|   |    ├── gameLoop: drive action of game level
│   |    ├── transitionToLevel: destroys and creates objects for game level
│   |    └── ...
|   |
│   └── ...
```

### Content Setup

Each level has a tag, background, platform, player, and callback function.  These attributes will be extended over time.  Immediately, it is very apparent, description is missing elements like enemies and objects in the game.  But, this progressive structure, enables Game Control to cycle from level to level on callback completion detection. 

- start/home sequence contains entry screen of game, this level could contain all game setup: player choice, speed, leader board.
- hills would contain classic mario game level(s)
- alien would contain adapted/personalized game level(s)
- gameover should contain logic for persistence, saving state in local storage, resume at point, start over, ...  


```javascript
/*  ==========================================
 *  ========== Game Level setup ==============
 *  ==========================================
 * Start/Homme sequence
 * a.) the start level awaits for button selection
 * b.) the start level automatically cycles to home level
 * c.) the home advances to 1st game screen when button selection is made
*/
GameLevel.create('start', '', '', '', startGameCallback);
GameLevel.create('home', '{{homeFile}}', '', '', homeScreenCallback);
// Game Screens
GameLevel.create('hills', '{{backgroundFile}}', '{{platformFile}}', '{{playerFile}}', testerCallBack);
GameLevel.create('alien', '{{backgroundFileAlt}}', '{{platformFile}}', '{{playerFile}}', testerCallBack);
// Test Game Screens, used during development and test
// GameLevel.create('noPlatform', '{{backgroundFileCastles}}', '', '{{playerFile}}', testerCallBack);
// GameLevel.create('noBackgroun', '', '{{platformFile}}', '{{playerFile}}', testerCallBack);
// Game Over
GameLevel.create('gameOver', '{{backgroundFileGameOver}}', '', '', gameOverCallBack);
```

### Callbacks

The callback on level currently supports advancement indicator.  The callback is continually be monitored in gameLoop and 

- store game status or game state to local storage
- capturing events in game that accumulate and store points


This below code is considered dummy code and is looking for purposefull implementation.  The callback is likely different for each game play level.

```javascript
// Level completion tester
function testerCallBack() {
    // console.log(GameEnv.player?.x)
    if (GameEnv.player?.x > 500) {
        return true;
    } else {
        return false;
    }
}
```

### Game Play

After creating GameLevel, game begins by starting the gameLoop.

```javascript
// start game
GameControl.gameLoop();
```

## Hacks: Next Steps

This "Hacks" section outlines a roadmap for enhancements.  It is believe that the structure of the game so far is flexible and scalable.  

All (software) engineering is a progressive set of tasks, a series of design, coding, tests, an failures. Each progression may spawn new features, adapt the current design and evolve the requirements of the game (levels).  Below are observed opportunities, these tasks represent the next set of obstacles...

### Scrolling screen
Elements to improve transitions of screens and backgrounds.

- Use a transition effect to smoothly move from the start screen to the game screen, etc.

- Overlaying Backgrounds
  - Implement a dual-layered background system where the primary background is static, and a passive background moves to create a parallax effect.
  - Adjust the opacity or blending mode to avoid shadows.

- Association with Character Movement
  - Trigger the scrolling screen movement when the player reaches a specific x-coordinate.
  - Synchronize the screen scrolling speed with the player's movement speed.
  - Consider incorporating easing functions for a smoother scrolling effect.

### Background, Platform, Player scaling
Review techniques for scaling key elements on screen to work in unison. 

- Scaling Techniques
  - Use responsive design principles to ensure that key game objects scale proportionally.
  - Use relative units (percentages) for sizing to maintain consistency across different screen sizes.

- Syncing Platform and Player
  - Adjust the scaling logic to ensure that the platform and player remain in sync with the background.
  - Consider using a container or wrapper to maintain relative positioning.

- Issues
  - Currently Platform and Player gets out of sync with regards to Background screen in smaller screen sizes.
  - Player size is not changing according to scaling of window size.

### Enemies, Obstacles
Make a game level that includes enemies and obstacles.  Here are some ideas...

- Obstacle Integration
  - Create a new obstacle (tube) GameObject class.
  - Implement logic to detect when the player interacts with the obstacle and trigger the callback.

- NPC Characters
  - Introduce a new NPC GameObject class for Goombas.
  - Implement logic for NPC movement and collision with the player.

### Jumping Animation, Collisions, Points
Interact with and destroy enemies.

- Collision Detection:
  - Implement collision detection between the player and enemies.
  - Assign points based on successful interactions, considering the type of interaction (e.g., jumping on a Goomba).

- Jump Animation:
  - Enhance the jump function to include different animations based on the direction and height of the jump.
  - Consider adding a gravity effect for realistic jumping.

- Issues
  - Jump currently spins
  - Jump does not consider direction

### Player flexibility
Look into a technique to change player froom Mario sprite to Alternative Sprite.

- Sprite Selection
  - Create a sprite selection screen where players can choose their character.
  - Save the selected sprite in local storage for continuity.

- Customizable Controls
  - Implement a control customization screen in the start menu
  - Allow players to redefine key mappings for movements (like arrow keys, spacebar)

### Player improvements
Improve animations and movements of player.  

- Idle Animation, idle()
  - Add an idle animation that plays when the player is not moving.
  - Include subtle movements to make the character appear more dynamic.

- Transitioning Movement, moveLeft() and moveRight()
  - Gradually transition from walking to running animations based on the duration of key presses.
  - Implement a deceleration effect when the player stops moving.

- Attack Animation attack()
  - Create an attack animation/scene that plays when the player interacts with enemies.
  - Implement logic to avoid enemy kills through proper timing of attacks.

### Game Over Screen, Leaderboard
Start a game leaderboard.  Use localstorage to record game play sessions, automatically at first. Time and points by level could be used as stats.

- Leaderboard Integration
  - Create a leaderboard system that records time and points for each game session.
  - Allow players to review and filter the leaderboard.

- Navigation Options
  - Return to the level
  - Go to the start screen
  - View the leaderboard.

### Start Screen
Add features to start screen(s) to allow things like ...

- Character Selection
  - Implement a character selection screen with previews of available characters.
  - Allow players to choose their character before starting the game.

- Speed and Enemies Selection
  - Include sliders or buttons for adjusting game speed and the number of enemies.
  - Reflect these changes in the game environment.

- Level Selection
  - Create a level selection screen with thumbnails and descriptions.
  - Allow players to choose the starting level.

- Leaderboard and Statistics
  - Include sections on the start screen for viewing the leaderboard and game statistics.
  - Provide an option to reset or clear statistics
