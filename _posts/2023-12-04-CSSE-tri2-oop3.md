---
toc: false
comments: false
layout: post
title: OOP, Multi Player
description: Start discussion on setting up two or more players in a game.  A key part of doing this is understanding all attributes in GameObject and GameEnv, serializing and esearilizing this information over the internet.
type: ccc
courses: { csse: {week: 16} }
---

## Multi Player
This is a dialog on regarding consideration on how to make a Multi Player game.

### Multiplayer Game Loop
Adjust the game loop to accommodate real-time updates from the server.
Touch Point: Modify the game loop to integrate server updates and adjust the timing mechanism.

### Player Actions
Player actions (like moving, jumping) are likely handled locally on the client side. In a multiplayer setup, these actions need to be sent to the server.
Touch Point: Modify handlePlayerAction to emit player actions to the server.

### JSON Representation
JSON or a similar data format can be used to represent game objects when transmitting them between the server and clients.
Touch Point: Serialize and deserialize game objects to/from JSON for network transmission.

### GameObject Lifecycle
Consider how GameObjects are created, updated, and destroyed in a multiplayer context.
Touch Point: Modify GameObject and GameLevel methods to handle synchronization and instantiation/destruction across clients.

### Server-Side Game State
The server needs to maintain the authoritative game state.
Touch Point: Server listens for player actions, updates the game state, and broadcasts the updated state to all connected clients.

### Synchronization
Ensure that all clients are synchronized with the server's authoritative game state.
Touch Point: Clients listen for updates from the server and adjust their local game state accordingly.

### Player Identification
Identify different players and associate their actions with their corresponding GameObjects.
Touch Point: Add a player identifier to emitted actions and update GameObjects accordingly.

### Networking (WebSocket):
Establishing and handling WebSocket connections for real-time communication.
Touch Point: Integrate WebSocket handling on both the client and server sides.

### Error Handling
Implement robust error handling to handle network failures and unexpected scenarios.
Touch Point: Enhance error handling mechanisms on both the client and server sides.

### Single Player Layout
```text
GameEnv
|   ├── Attributes:
│   |   ├── levels
│   |   ├── gameObjects
|   │   └── ...
|   |
|   ├── Methods: 
│   |    ├── update: update, draw
│   |    ├── destroy: all gameObjects
│   |    └── ...
│
├── GameObject
│   ├── Player: sprite animation, wasd
│   ├── Background: fit to screen, scrolling 
│   ├── Platform: fixed to bottom, scrolling
│   └── ...
│
├── GameLevel
|   ├── Tag: key
│   ├── Attributes:
│   |   ├── playerAssets
│   |   ├── backgroundAssets
│   |   ├── platformAssets
│   |   └── ...
|   |
│   └── Methods: 
│   |    ├── load: "new" GameObject created from assets
│   |    └── ...
|
└── GameControl
│   ├── Methods: 
|   |    ├── gameLoop: drive action of game level
│   |    ├── transitionToLevel: destroys and creates objects for game level
│   |    └── ...
|   |
│   └── ...
```

## Game States
Some of the definition above talk about "game state".

### Positions and States of Game Objects
The location, velocity, and state (e.g., alive, dead) of each game object (players, enemies, platforms, etc.).

### Player Scores and Stats
Scores, achievements, or any other player-specific statistics.

### Level Information
Details about the current level, such as the background, platform configuration, and any other level-specific attributes.

### Time and Game Clock
Information about the current time within the game, which is crucial for handling events, animations, and other time-dependent actions.

### Event Queue or Log
A log of events or actions that have occurred, which can be used for synchronization and debugging.

### Game Configuration
Settings and configurations that affect the game's behavior, such as gravity, game speed, or other global parameters.

### Player Identification and Session Information:
Unique identifiers for players, their session information, and any relevant details for tracking and managing player connections.
## Client / Server Code

To make a game multiplayer or enable two machines to share the same GameLevel with different players, you would indeed need to introduce a mechanism for communication between the two instances. WebSockets are a commonly used technology for real-time bidirectional communication between clients and servers, and they can be a good choice for multiplayer games.

- Server-Side Logic
  - Implement a server to manage the game state, including the current GameLevel, player positions, and other relevant data.
  - Use a WebSocket library on the server to handle communication with clients.

- Client-Side Logic
  - Modify the existing game code on the client to interact with the server via WebSockets.
  - When a player performs an action (e.g., moves the character), send that action to the server.
  - Receive updates from the server, such as the positions of other players, and update the local game state accordingly.

- Synchronization
  - Ensure that the server is the authority on the game state. All clients should receive updates from the server and synchronize their local state accordingly.
  - Implement mechanisms for handling latency and potential synchronization issues between clients.

- WebSockets:
  - Use WebSockets to establish a persistent connection between the clients and the server.
  - Send messages back and forth between the server and clients to keep them in sync.


### Code Outlines
Client Code Sample: JavaScript

```javascript

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.3/socket.io.js"></script>

// Client-side using JavaScript and Socket.IO
const socket = io.connect('http://localhost:5000');   // change to server for multi player

socket.on('gameState', (updatedGameState) => {
  // Update the local game state based on the server updates
});

// When the player performs an action
function handlePlayerAction(action) {
  // Send the action to the server
  socket.emit('playerAction', action);
  // Local client may update its state immediately, but the authoritative state comes from the server
}
```

Server Code Sample: Python

```python
from flask import Flask, render_template
from flask_socketio import SocketIO

app = Flask(__name__)
socketio = SocketIO(app)

@app.route('/')
def index():
    return render_template('index.html')

@socketio.on('connect')
def handle_connect():
    # Handle new player connection

@socketio.on('playerAction')
def handle_player_action(action):
    # Handle player actions and update the game state
    # Broadcast the updated state to all connected clients
    socketio.emit('gameState', updated_game_state)

if __name__ == '__main__':
    socketio.run(app)
```
